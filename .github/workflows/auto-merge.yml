name: Auto-merge non-main branches into main

on:
  push:
    branches-ignore:
      - main

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  create-and-automerge-pr:
    name: Create/Update PR to main and enable auto-merge
    runs-on: ubuntu-latest
    if: github.ref_name != 'main'
    steps:
      - name: Checkout branch
        uses: actions/checkout@v4

      - name: Ensure PR open (head -> main)
        id: ensure_pr
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const headBranch = process.env.GITHUB_REF.replace('refs/heads/','');
            const head = `${owner}:${headBranch}`;
            const base = 'main';

            // Find an existing PR from this head to main
            const { data: prs } = await github.rest.pulls.list({ owner, repo, state: 'open', head, base, per_page: 1 });
            let pr;
            if (prs.length > 0) {
              pr = prs[0];
              core.info(`Found existing PR #${pr.number} -> ${base}`);
            } else {
              const title = `Auto-merge: ${headBranch} -> ${base}`;
              const body = 'This PR was opened automatically to merge the branch into main once checks pass.';
              const created = await github.rest.pulls.create({ owner, repo, head: headBranch, base, title, body, maintainer_can_modify: true });
              pr = created.data;
              core.info(`Created PR #${pr.number} -> ${base}`);
            }

            core.setOutput('number', pr.number.toString());
            core.setOutput('node_id', pr.node_id);

      - name: Check for merge conflicts
        id: mergeability
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const number = Number(core.getInput('pr_number')) || Number(process.env.PR_NUMBER) || Number('${{ steps.ensure_pr.outputs.number }}');

            // GitHub may need a moment to compute mergeability; poll briefly
            async function getMergeable() {
              const { data } = await github.rest.pulls.get({ owner, repo, pull_number: number });
              return data;
            }

            let pr = await getMergeable();
            let attempts = 0;
            while (pr.mergeable === null && attempts < 6) {
              await new Promise(r => setTimeout(r, 2000));
              pr = await getMergeable();
              attempts++;
            }

            core.info(`mergeable: ${pr.mergeable}, mergeable_state: ${pr.mergeable_state}`);

            if (pr.mergeable === false && pr.mergeable_state === 'dirty') {
              core.setFailed('Merge conflict with main detected. Please rebase or resolve conflicts.');
            }

      - name: Enable auto-merge (squash)
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const pullRequestId = '${{ steps.ensure_pr.outputs.node_id }}';
            const query = `mutation($pullRequestId: ID!) {\n  enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: SQUASH }) {\n    clientMutationId\n  }\n}`;
            try {
              await github.graphql(query, { pullRequestId });
              core.info('Auto-merge enabled. The PR will merge once required checks pass.');
            } catch (error) {
              // If auto-merge cannot be enabled, surface the reason
              core.setFailed(`Failed to enable auto-merge: ${error.message}`);
            }


